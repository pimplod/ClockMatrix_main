/* ***************************************************************************
 **    tmp75.c
 **
 **  Project      : ClockMatrix_v0
 **  Target       : PIC18F14K50
 **  Description  : Project used to develop clock firmware.  Tested methods and
 **                 determined functionality (needed, wanted, and the possible)
 **
 **  Compiler     : HI-TECH C  Version 9.80
 **  IDE          : MPLABX v1.80
 **  Created      : 5/8/2013
 **  Branched     : 6/27/2013 -- started v2
 **
 **  R Hanlen <implod@gmail.com>
 ** ***************************************************************************/

/*****************************************************************************
 **HEADER FILES
 *****************************************************************************/

//Compiler-Standard
#include <htc.h>
#include <stdint.h>        /* For uint8_t definition */
#include <stdbool.h>       /* For true/false definition */

//Project
#include "global.h"
#include "tmp75.h"
#include "swI2C.h"

/*****************************************************************************
 **LOCAL FUNCTION PROTOTYPES
 *****************************************************************************/

//uint8_t Read8Bit(uint8_t reg);
//uint16_t Read16Bit(uint8_t reg);
//void Write8Bit(uint8_t reg, uint8_t data);

/*****************************************************************************
 **VARIABLES
 *****************************************************************************/

/*****************************************************************************
 **FUNCTIONS
 *****************************************************************************/

//uint8_t Read8Bit(uint8_t reg){
//
//    uint8_t data;
//    StartI2C(); // Issue start signal
//    TransmitI2C(LM75_ID); // Device ID
//    TransmitI2C(reg); // Register to Read
//    StartI2C(); // Issue repeated start signal
//    TransmitI2C(0x91); // Device plus R/W=1
//    data = RecieveI2C(0);
//    StopI2C();
//
//    return data;
//}
//
//uint16_t Read16Bit(uint8_t reg){
//
//    uint16_t data;
//    StartI2C(); // Issue start signal
//    TransmitI2C(LM75_ID); // Device
//    TransmitI2C(reg); // Address
//    StartI2C(); // Issue repeated start signal
//    TransmitI2C(0x91); // Device plus R/W=1
//    data = RecieveI2C(1); // Read seconds byte
//    data = data << 8 | RecieveI2C(0);
//    StopI2C(); // Issue stop signal
//
//    return data;
//}
//
//void Write8Bit(uint8_t reg, uint8_t data){
//
//    StartI2C(); // Issue start signal
//    TransmitI2C(LM75_ID); // Device
//    TransmitI2C(reg); //  Address
//    TransmitI2C(data);
//    StopI2C();
//}

uint8_t LM75Init(void){

    if(AckPolling(LM75_ID)){
        return(49);
    }

    StartI2C(); // Issue start signal
    TransmitI2C(LM75_ID); // Device
    TransmitI2C(LM75_TEMP_REGISTER); // Address
    StopI2C();

    return (48);
}

uint16_t LM75GetTemp(uint8_t write){

    uint16_t tempHi,tempLo;

    // Address pointer does not auto advance when register is read.
    if(write){
    StartI2C(); // Issue start signal
    TransmitI2C(LM75_ID); // Device
    TransmitI2C(LM75_TEMP_REGISTER); // Address
    StopI2C();
    NOP();
    }
    // Re-read temperature without having to write address each iteration.
    StartI2C(); // Issue repeated start signal
    TransmitI2C(0x91); // Device plus R/W=1
    tempHi = RecieveI2C(1); // Read seconds byte
    tempLo = RecieveI2C(0);
    tempHi = ((tempHi << 3)+(tempLo >> 5))*125/1000;
    StopI2C(); // Issue stop signal

    return tempHi;



}

//uint8_t LM75GetConfig(void){
//    return (Read8Bit(LM75_CONFIG_REGISTER));
//}
//
//void LM75setConfig(uint8_t config){
//
//    Write8Bit(LM75_CONFIG_REGISTER, config);
//}


