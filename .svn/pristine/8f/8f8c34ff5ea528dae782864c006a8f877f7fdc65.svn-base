/* ***************************************************************************
 **    DS1307.c
 **
 **  Project      : ClockMatrix_v0
 **  Target       : PIC18F14K50
 **  Description  : Project used to develop clock firmware.  Tested methods and
 **                 determined functionality (needed, wanted, and the possible)
 **
 **  Compiler     : HI-TECH C  Version 9.80
 **  IDE          : MPLABX v1.80
 **  Created      : 5/8/2013
 **  Branched     : 6/27/2013 -- started v2
 **
 **  R Hanlen <implod@gmail.com>
 ** ***************************************************************************/

/*****************************************************************************
 **HEADER FILES
 *****************************************************************************/
//  Global
#include <htc.h>
#include <stdint.h>
#include <string.h>

//  Local
#include "global.h"
#include "DS1307.h"
#include "swI2C.h"

/*****************************************************************************
 **VARABLES
 *****************************************************************************/

/*****************************************************************************
 **FUNCTIONS
 *****************************************************************************/

uint8_t RTCInit(void){

    if (AckPolling(DS1307_ID)) { //check if rtc responds on i2c bus
        return(RTC_NOT_RESPONDING);
    }

    RTCGetDateTime();
    //RTCGetControl();
    RTCGetAlarm();
    if (dateTime.sec > 60) { //check if oscillator is running
        //RTCStartClock();
        return(RTC_CLOCKHALT_BIT_SET);
    }

    return(RTC_INITIALIZED);  // everything checks out
}

void RTCStartClock(void){

    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Address
    TransmitI2C(RTC_SECONDS); // Start from address 0
    TransmitI2C(0x00);
    StopI2C();

}

void RTCStopClock(void){

    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_SECONDS); // Address
    TransmitI2C(RTC_CH_BIT);
    StopI2C();

}

void RTCGetDateTime(void){

    uint8_t i2cBuffer;
    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_SECONDS); // Address
    StartI2C(); // Issue repeated start signal
    TransmitI2C(0xD1); // Device plus R/W=1
    i2cBuffer = RecieveI2C(1); // Read seconds byte
    dateTime.sec = bcd_to_dec(i2cBuffer);
    i2cBuffer = RecieveI2C(1); // Read minutes byte
    dateTime.min = bcd_to_dec(i2cBuffer);
    i2cBuffer = RecieveI2C(1); // Read hours byte
    dateTime.hour = bcd_to_dec(i2cBuffer & 0x1F);
    i2cBuffer = RecieveI2C(1); // Read day of week byte
    dateTime.wday = bcd_to_dec(i2cBuffer);
    i2cBuffer = RecieveI2C(1); //Read date of month
    dateTime.mday = bcd_to_dec(i2cBuffer);
    i2cBuffer = RecieveI2C(1); // Read month byte
    dateTime.mon = bcd_to_dec(i2cBuffer);
    i2cBuffer = RecieveI2C(0); // Read last to digits of year byte
    dateTime.year = bcd_to_dec(i2cBuffer);
    StopI2C(); // Issue stop signal

    TimeString();
}

void RTCSetTime(void){
    uint8_t i2cBuffer;

    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_SECONDS); // Address
    i2cBuffer = dec_to_bcd(dateTime.sec);
    TransmitI2C(i2cBuffer); //seconds
    i2cBuffer = dec_to_bcd(dateTime.min);
    TransmitI2C(i2cBuffer); //minutes
    i2cBuffer = dec_to_bcd(dateTime.hour);
    TransmitI2C(i2cBuffer | 0x40); //hours
    i2cBuffer = dec_to_bcd(dateTime.wday);
    TransmitI2C(i2cBuffer); //Day
    i2cBuffer = dec_to_bcd(dateTime.mday);
    TransmitI2C(i2cBuffer); //Date
    i2cBuffer = dec_to_bcd(dateTime.mon);
    TransmitI2C(i2cBuffer); //Month
    i2cBuffer = dec_to_bcd(dateTime.year);
    TransmitI2C(i2cBuffer); //Year
    StopI2C();

}

void RTCGetControl(void){

    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_CONTROL); // Address
    StartI2C(); // Issue repeated start signal
    TransmitI2C(0xD1); // Device plus R/W=1
    dateTime.cntrl = RecieveI2C(0); // Read seconds byte
    StopI2C(); // Issue stop signal

}

void RTCSetControl(uint8_t value){

    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_CONTROL); // Address
    TransmitI2C(value); //seconds
    StopI2C();

}

void RTCGetAlarm(void){

     StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_RAM_START); // Address
    StartI2C(); // Issue repeated start signal
    TransmitI2C(0xD1); // Device plus R/W=1
    alarmTime.min = RecieveI2C(1);
    alarmTime.hour = RecieveI2C(0);
    StopI2C();

    AlarmString();
}

void RTCSetAlarm(void){

    StartI2C(); // Issue start signal
    TransmitI2C(DS1307_ID); // Device
    TransmitI2C(RTC_RAM_START); // Address
    TransmitI2C(alarmTime.min);
    TransmitI2C(alarmTime.hour);
    StopI2C();
}

//void RTCReadRAM(uint8_t startAddress, uint8_t byteCount, uint8_t *RAMptr){
//
//    uint8_t i = 0;
//    StartI2C(); // Issue start signal
//    TransmitI2C(DS1307_ID); // Device
//    TransmitI2C(startAddress); // Address
//    StartI2C(); // Issue repeated start signal
//    TransmitI2C(0xD1); // Device plus R/W=1
//    while (--byteCount){
//    RAMptr[i] = RecieveI2C(1); // Read seconds byte
//    i++;
//    }
//    RAMptr[i] = RecieveI2C(0); // Read minutes byte
//    StopI2C(); // Issue stop signal
//}
//
//void RTCWriteRAM(uint8_t startAddr, uint8_t bytes, uint8_t *RAMdata){
//
//    uint8_t count = 0;
//    StartI2C(); // Issue start signal
//    TransmitI2C(DS1307_ID); // Device
//    TransmitI2C(startAddr); // Address
//    for (count = 0; count < bytes; count++){
//    TransmitI2C(RAMdata[count]);
//    }
//    StopI2C();
//
//}

void TimeString(void){

    if (((dateTime.hour) / 10) > 0) {
        if (dateTime.hour == 11) {
            dateTime.time_string[0] = 33;// '!'
            dateTime.time_string[1] = 33;// '!'
        } else {
            dateTime.time_string[0] = 33;// '!'
            dateTime.time_string[1] = (dateTime.hour % 10) + 48;// '0'
        }
    } else {
        dateTime.time_string[0] = 32;// ' '
        dateTime.time_string[1] = (dateTime.hour % 10) + 48;// '0'
    }
    dateTime.time_string[2] = 58;// ':'
    dateTime.time_string[3] = (dateTime.min / 10) + 48;// '0'
    dateTime.time_string[4] = (dateTime.min % 10) + 48;// '0'
    dateTime.time_string[5] = '\0';

} // string length = 5

void AlarmString(void){
    if (((alarmTime.hour) / 10) > 0) {
        alarmTime.alarm_string[0] = '!';
    }else alarmTime.alarm_string[0] = ' ';
   alarmTime.alarm_string[1] = (alarmTime.hour % 10) + '0';
   alarmTime.alarm_string[2] = ':';
   alarmTime.alarm_string[3] = (alarmTime.min / 10) + '0';
   alarmTime.alarm_string[4] = (alarmTime.min % 10) + '0';
   alarmTime.alarm_string[5] = '\0';

} // string length = 5

void DateString(char *string){

    unsigned char number1, number2;
    int length;

    //RTCGetDateTime();
    // Blank the string
    string[0] = '\0';

    switch (dateTime.wday) {
        case 1: strcat(string, "MONDAY ");
            break;
        case 2: strcat(string, "TUESDAY ");
            break;
        case 3: strcat(string, "WEDNESDAY ");
            break;
        case 4: strcat(string, "THURSDAY ");
            break;
        case 5: strcat(string, "FRIDAY ");
            break;
        case 6: strcat(string, "SATURDAY ");
            break;
        case 7: strcat(string, "SUNDAY ");
            break;
    }

    switch (dateTime.mon) {
        case 1: strcat(string, "JANUARY ");
            break;
        case 2: strcat(string, "FEBUARY ");
            break;
        case 3: strcat(string, "MARCH ");
            break;
        case 4: strcat(string, "APRIL ");
            break;
        case 5: strcat(string, "MAY ");
            break;
        case 6: strcat(string, "JUNE ");
            break;
        case 7: strcat(string, "JULY ");
            break;
        case 8: strcat(string, "AUGUST ");
            break;
        case 9: strcat(string, "SEPTEMBER ");
            break;
        case 10: strcat(string, "OCTOBER ");
            break;
        case 11: strcat(string, "NOVEMBER ");
            break;
        case 12: strcat(string, "DECEMBER ");
            break;
    }

    //strcat(string, "the ");

    if (dateTime.mday < 10) number1 = 0;
    else number1 = dateTime.mday / 10;

    number2 = dateTime.mday - (number1 * 10);

    if (number1 > 0) {
        length = strlen(string);
        string[length] = number1 + 48;
        string[length + 1] = '\0';
    }

    length = strlen(string);
    string[length] = number2 + 48;
    string[length + 1] = '\0';

    if (number1 == 1) {
        strcat(string, "TH ");
    } else {
        if (number2 == 1) strcat(string, "ST ");
        else if (number2 == 2) strcat(string, "ND ");
        else if (number2 == 3) strcat(string, "RD ");
        else strcat(string, "TH ");
    }
   
}  // string length <= 25

uint8_t bcd_to_dec(uint8_t bcd){
    return(bcd & 0x0f) + ((bcd >> 4) * 10);
}

uint8_t dec_to_bcd(uint8_t dec){
    return(((dec / 10) << 4)+ (dec % 10));
}